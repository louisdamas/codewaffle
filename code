import rospy
from geometry_msgs.msg import Twist
from sensor_msgs.msg import LaserScan

# Initialiser un nœud ROS
rospy.init_node('circle_movement')

# Créer un publisher pour les commandes de vitesse
pub = rospy.Publisher('/cmd_vel', Twist, queue_size=10)
rate = rospy.Rate(10)  # 10 Hz

# Définir la vitesse et le rayon du cercle
velocity_msg = Twist()
velocity_msg.linear.x = 0.2  # Vitesse linéaire (m/s)
velocity_msg.angular.z = 0.5  # Vitesse angulaire (rad/s)

# Fonction de callback pour les données LIDAR
def lidar_callback(data):
    global velocity_msg
    # Déterminer si un obstacle est détecté dans une certaine plage
    if min(data.ranges) < 0.5:  # par exemple, moins de 0.5 mètre
        # Arrêter le robot
        velocity_msg.linear.x = 0
        velocity_msg.angular.z = 0
    else:
        # Sinon, continuer à avancer
        velocity_msg.linear.x = 0.2
        velocity_msg.angular.z = 0.5

# Souscrire au topic LIDAR
lidar_sub = rospy.Subscriber('/scan', LaserScan, lidar_callback)

# Boucle principale
try:
    while not rospy.is_shutdown():
        pub.publish(velocity_msg)
        rate.sleep()
finally:
    # Pour arrêter le robot, envoyez une vitesse nulle
    velocity_msg.linear.x = 0
    velocity_msg.angular.z = 0
    pub.publish(velocity_msg)
